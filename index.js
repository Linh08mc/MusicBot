require('dotenv').config();
const { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ActivityType, StringSelectMenuBuilder } = require('discord.js');

const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.send('Bot √¢m nh·∫°c Discord ƒëang ch·∫°y!');
});

app.listen(port, '0.0.0.0', () => {
  console.log(`M√°y ch·ªß Express ƒëang ch·∫°y tr√™n c·ªïng ${port}`);
});

const { Manager } = require('erela.js');

const nodes = [{
  name: 'xx',
  host: 'lavalink.serenetia.com',
  port: 443,
  password: 'https://dsc.gg/ajidevserver',
  secure: false,
}];

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
  ],
});

const manager = new Manager({
  nodes,
  send(id, payload) {
    const guild = client.guilds.cache.get(id);
    if (guild) guild.shard.send(payload);
  },
  defaultSearchPlatform: 'youtube',
  autoPlay: true,
  clientName: `${client.user?.username || 'Music Bot'}`,
  plugins: []
});

const commands = [
  new SlashCommandBuilder()
    .setName('play')
    .setDescription('Ph√°t m·ªôt b√†i h√°t')
    .addStringOption(option => 
      option.setName('query')
        .setDescription('T√™n b√†i h√°t ho·∫∑c URL')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('pause')
    .setDescription('T·∫°m d·ª´ng b√†i h√°t hi·ªán t·∫°i'),
  new SlashCommandBuilder()
    .setName('resume')
    .setDescription('Ti·∫øp t·ª•c b√†i h√°t hi·ªán t·∫°i'),
  new SlashCommandBuilder()
    .setName('skip')
    .setDescription('Chuy·ªÉn sang b√†i h√°t ti·∫øp theo'),
  new SlashCommandBuilder()
    .setName('queue')
    .setDescription('Hi·ªÉn th·ªã danh s√°ch ph√°t hi·ªán t·∫°i'),
  new SlashCommandBuilder()
    .setName('nowplaying')
    .setDescription('Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t'),
  new SlashCommandBuilder()
    .setName('shuffle')
    .setDescription('X√°o tr·ªôn danh s√°ch ph√°t'),
  new SlashCommandBuilder()
    .setName('loop')
    .setDescription('B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô l·∫∑p')
    .addStringOption(option =>
      option.setName('mode')
        .setDescription('Ch·∫ø ƒë·ªô l·∫∑p')
        .setRequired(true)
        .addChoices(
          { name: 'T·∫Øt', value: 'off' },
          { name: 'B√†i h√°t', value: 'track' },
          { name: 'Danh s√°ch', value: 'queue' }
        )),
  new SlashCommandBuilder()
    .setName('remove')
    .setDescription('X√≥a m·ªôt b√†i h√°t kh·ªèi danh s√°ch ph√°t')
    .addIntegerOption(option =>
      option.setName('position')
        .setDescription('V·ªã tr√≠ trong danh s√°ch')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('move')
    .setDescription('Di chuy·ªÉn b√†i h√°t ƒë·∫øn v·ªã tr√≠ kh√°c')
    .addIntegerOption(option =>
      option.setName('from')
        .setDescription('V·ªã tr√≠ ban ƒë·∫ßu')
        .setRequired(true))
    .addIntegerOption(option =>
      option.setName('to')
        .setDescription('V·ªã tr√≠ m·ªõi')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('clearqueue')
    .setDescription('X√≥a to√†n b·ªô danh s√°ch ph√°t'),
  new SlashCommandBuilder()
    .setName('stop')
    .setDescription('D·ª´ng nh·∫°c v√† tho√°t'),
  new SlashCommandBuilder()
    .setName('volume')
    .setDescription('ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng')
    .addIntegerOption(option =>
      option.setName('level')
        .setDescription('M·ª©c √¢m l∆∞·ª£ng (0-100)')
        .setRequired(true)),
  new SlashCommandBuilder()
    .setName('247')
    .setDescription('B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô 24/7'),
  new SlashCommandBuilder()
    .setName('help')
    .setDescription('Hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh'),
  new SlashCommandBuilder()
    .setName('invite')
    .setDescription('L·∫•y li√™n k·∫øt m·ªùi bot'),
  new SlashCommandBuilder()
    .setName('ping')
    .setDescription('Hi·ªÉn th·ªã ƒë·ªô tr·ªÖ c·ªßa bot'),
  new SlashCommandBuilder()
    .setName('stats')
    .setDescription('Hi·ªÉn th·ªã th·ªëng k√™ c·ªßa bot'),
  new SlashCommandBuilder()
    .setName('support')
    .setDescription('Tham gia m√°y ch·ªß h·ªó tr·ª£'),

].map(command => command.toJSON());

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_BOT_TOKEN);

client.once('ready', async () => {
  console.log(`ƒê√£ ƒëƒÉng nh·∫≠p v·ªõi t√™n ${client.user.tag}`);
  manager.init(client.user.id);

  client.user.setActivity('/help | @Nutifood', { type: ActivityType.Listening });

  try {
    console.log('ƒêang l√†m m·ªõi l·ªánh slash...');
    await rest.put(Routes.applicationCommands(client.user.id), { body: commands });
    console.log('L·ªánh slash ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.');
  } catch (error) {
    console.error(error);
  }
});

client.on('raw', (data) => manager.updateVoiceState(data));

function createMusicEmbed(track) {
  return new EmbedBuilder()
    .setTitle('üéµ ƒêang ph√°t')
    .setDescription(`[${track.title}](${track.uri})`)
    .addFields(
      { name: 'üë§ Ngh·ªá sƒ©', value: track.author, inline: true },
      { name: '‚è±Ô∏è Th·ªùi l∆∞·ª£ng', value: formatDuration(track.duration), inline: true }
    )
    .setThumbnail(track.thumbnail)
    .setColor('#FF0000');
}

function formatDuration(duration) {
  const minutes = Math.floor(duration / 60000);
  const seconds = ((duration % 60000) / 1000).toFixed(0);
  return `${minutes}:${seconds.padStart(2, '0')}`;
}

function createControlButtons() {
  return [
    new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('pause')
          .setLabel('T·∫°m d·ª´ng/Ti·∫øp t·ª•c')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('skip')
          .setLabel('B·ªè qua')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('stop')
          .setLabel('D·ª´ng')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('loop')
          .setLabel('L·∫∑p')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('queue')
          .setLabel('Danh s√°ch')
          .setStyle(ButtonStyle.Secondary)
      )
  ];
}

client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand() && !interaction.isButton() && !interaction.isStringSelectMenu()) return;

  if (interaction.isButton()) {
    if (!interaction.member.voice.channel) {
      return interaction.reply({ content: 'B·∫°n c·∫ßn tham gia k√™nh tho·∫°i ƒë·ªÉ s·ª≠ d·ª•ng c√°c n√∫t!', ephemeral: true });
    }
    const player = manager.players.get(interaction.guild.id);
    if (!player) return;

    const currentTrack = player.queue.current;
    if (!currentTrack) return;

    if (currentTrack.requester.id !== interaction.user.id) {
      return interaction.reply({ content: 'Ch·ªâ ng∆∞·ªùi y√™u c·∫ßu b√†i h√°t n√†y m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c n√∫t n√†y!', ephemeral: true });
    }

    switch (interaction.customId) {
      case 'pause':
        player.pause(!player.paused);
        await interaction.reply({ content: player.paused ? 'ƒê√£ t·∫°m d·ª´ng' : 'ƒê√£ ti·∫øp t·ª•c', ephemeral: true });
        break;
      case 'skip':
        const skipMessage = player.get('currentMessage');
        if (skipMessage && skipMessage.editable) {
          const disabledButtons = skipMessage.components[0].components.map(button => {
            return ButtonBuilder.from(button).setDisabled(true);
          });
          skipMessage.edit({ components: [new ActionRowBuilder().addComponents(disabledButtons)] });
        }
        if (player.queue.length === 0) {
          const queueEndEmbed = new EmbedBuilder()
            .setDescription('Danh s√°ch ph√°t ƒë√£ k·∫øt th√∫c!')
            .setColor('#FF0000')
            .setTimestamp();
          await interaction.channel.send({ embeds: [queueEndEmbed] });
          player.set('manualStop', true);
        }
        player.stop();
        await interaction.reply({ content: 'ƒê√£ b·ªè qua', ephemeral: true });
        break;
      case 'stop':
        const stopMessage = player.get('currentMessage');
        if (stopMessage && stopMessage.editable) {
          const disabledButtons = stopMessage.components[0].components.map(button => {
            return ButtonBuilder.from(button).setDisabled(true);
          });
          stopMessage.edit({ components: [new ActionRowBuilder().addComponents(disabledButtons)] });
        }
        player.set('manualStop', true);
        const stopEmbed = new EmbedBuilder()
          .setDescription('Danh s√°ch ph√°t ƒë√£ k·∫øt th√∫c!')
          .setColor('#FF0000')
          .setTimestamp();
        await interaction.channel.send({ embeds: [stopEmbed] });
        player.destroy();
        await interaction.reply({ content: 'ƒê√£ d·ª´ng', ephemeral: true });
        break;
      case 'loop':
        player.setQueueRepeat(!player.queueRepeat);
        await interaction.reply({ content: `L·∫∑p: ${player.queueRepeat ? 'ƒê√£ b·∫≠t' : 'ƒê√£ t·∫Øt'}`, ephemeral: true });
        break;
      case 'queue':
        const queue = player.queue;
        const currentTrack = player.queue.current;
        let description = queue.length > 0 ? queue.map((track, i) => 
          `${i + 1}. [${track.title}](${track.uri})`).join('\n') : 'Kh√¥ng c√≥ b√†i h√°t trong danh s√°ch';

        if (currentTrack) description = `**ƒêang ph√°t:**\n[${currentTrack.title}](${currentTrack.uri})\n\n**Danh s√°ch:**\n${description}`;

        const embed = new EmbedBuilder()
          .setTitle('Danh s√°ch ph√°t')
          .setDescription(description)
          .setColor('#FF0000')
          .setTimestamp();
        await interaction.reply({ embeds: [embed], ephemeral: true });
        break;
    }
    return;
  }

  if (interaction.isStringSelectMenu() && interaction.customId === 'filter') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return;

    const filter = interaction.values[0];
    player.node.send({
      op: 'filters',
      guildId: interaction.guild.id,
      [filter]: true
    });

    const embed = new EmbedBuilder()
      .setDescription(`üéµ ƒê√£ √°p d·ª•ng b·ªô l·ªçc: ${filters[filter]}`)
      .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
    return;
  }

  const { commandName, options } = interaction;

  if (commandName === 'play') {
    if (!interaction.member.voice.channel) {
      return interaction.reply({ content: 'H√£y tham gia k√™nh tho·∫°i tr∆∞·ªõc!', ephemeral: true });
    }

    const player = manager.create({
      guild: interaction.guild.id,
      voiceChannel: interaction.member.voice.channel.id,
      textChannel: interaction.channel.id,
      selfDeafen: true
    });

    if (!player.twentyFourSeven) player.twentyFourSeven = false;

    player.connect();

    const query = options.getString('query');
    const res = await manager.search(query, interaction.user);

    switch (res.loadType) {
      case 'TRACK_LOADED':
      case 'SEARCH_RESULT':
        if (!res.tracks || res.tracks.length === 0) {
          await interaction.reply({ content: 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£! Vui l√≤ng th·ª≠ t·ª´ kh√≥a t√¨m ki·∫øm kh√°c.', ephemeral: true });
          return;
        }
        const track = res.tracks[0];
        player.queue.add(track);
        const embed = new EmbedBuilder()
          .setDescription(`ƒê√£ th√™m [${track.title}](${track.uri}) v√†o danh s√°ch ph√°t`)
          .setColor('#FF0000')
          .setFooter({ 
            text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
            iconURL: interaction.user.displayAvatarURL()
          })
          .setTimestamp();
        await interaction.reply({ embeds: [embed] });
        if (!player.playing && !player.paused) player.play();
        break;
      case 'NO_MATCHES':
        await interaction.reply({ content: 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£! Vui l√≤ng th·ª≠ t·ª´ kh√≥a t√¨m ki·∫øm kh√°c.', ephemeral: true });
        break;
      case 'LOAD_FAILED':
        await interaction.reply({ content: 'Kh√¥ng th·ªÉ t·∫£i b√†i h√°t! Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c s·ª≠ d·ª•ng li√™n k·∫øt kh√°c.', ephemeral: true });
        break;
    }
  }

  if (commandName === 'pause') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    player.pause(true);
    const embed = new EmbedBuilder()
      .setDescription('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng')
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'resume') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    player.pause(false);
    const embed = new EmbedBuilder()
      .setDescription('‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c')
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'skip') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    player.stop();
    const embed = new EmbedBuilder()
      .setDescription('‚è≠Ô∏è ƒê√£ b·ªè qua')
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'queue') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const queue = player.queue;
    const currentTrack = player.queue.current;
    let description = queue.length > 0 ? queue.map((track, i) => 
      `${i + 1}. [${track.title}](${track.uri})`).join('\n') : 'Kh√¥ng c√≥ b√†i h√°t trong danh s√°ch';

    if (currentTrack) description = `**ƒêang ph√°t:**\n[${currentTrack.title}](${currentTrack.uri})\n\n**Danh s√°ch:**\n${description}`;

    const embed = new EmbedBuilder()
      .setTitle('üéµ Danh s√°ch ph√°t')
      .setDescription(description)
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'nowplaying') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const track = player.queue.current;
    if (!track) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const embed = createMusicEmbed(track);
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'shuffle') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    player.queue.shuffle();
    const embed = new EmbedBuilder()
      .setDescription('üîÄ ƒê√£ x√°o tr·ªôn danh s√°ch ph√°t')
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'loop') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const mode = options.getString('mode');
    switch (mode) {
      case 'off':
        player.setQueueRepeat(false);
        player.setTrackRepeat(false);
        break;
      case 'track':
        player.setQueueRepeat(false);
        player.setTrackRepeat(true);
        break;
      case 'queue':
        player.setQueueRepeat(true);
        player.setTrackRepeat(false);
        break;
    }

    const embed = new EmbedBuilder()
      .setDescription(`üîÑ Ch·∫ø ƒë·ªô l·∫∑p ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh: ${mode}`)
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'remove') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const pos = options.getInteger('position') - 1;
    if (pos < 0 || pos >= player.queue.length) {
      return interaction.reply({ content: 'V·ªã tr√≠ kh√¥ng h·ª£p l·ªá!', ephemeral: true });
    }

    const removed = player.queue.remove(pos);
    const embed = new EmbedBuilder()
      .setDescription(`‚ùå ƒê√£ x√≥a [${removed.title}](${removed.uri})`)
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'move') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const from = options.getInteger('from') - 1;
    const to = options.getInteger('to') - 1;

    if (from < 0 || from >= player.queue.length || to < 0 || to >= player.queue.length) {
      return interaction.reply({ content: 'V·ªã tr√≠ kh√¥ng h·ª£p l·ªá!', ephemeral: true });
    }

    const track = player.queue[from];
    player.queue.remove(from);
    player.queue.add(track, to);

    const embed = new EmbedBuilder()
      .setDescription(`üì¶ ƒê√£ di chuy·ªÉn [${track.title}](${track.uri}) ƒë·∫øn v·ªã tr√≠ ${to + 1}`)
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'clearqueue') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    player.queue.clear();
    const embed = new EmbedBuilder()
      .setDescription('üóëÔ∏è ƒê√£ x√≥a to√†n b·ªô danh s√°ch ph√°t')
      .setColor('#FF0000')
      .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`, iconURL: interaction.user.displayAvatarURL() })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'stop') {
    const player = manager.players.get(interaction.guild.id);
    if (player) {
      player.set('manualStop', true);
      const stopMessage = player.get('currentMessage');
      if (stopMessage && stopMessage.editable) {
        const disabledButtons = stopMessage.components[0].components.map(button => {
          return ButtonBuilder.from(button).setDisabled(true);
        });
        stopMessage.edit({ components: [new ActionRowBuilder().addComponents(disabledButtons)] });
      }
      const stopEmbed = new EmbedBuilder()
        .setDescription('Danh s√°ch ph√°t ƒë√£ k·∫øt th√∫c!')
        .setColor('#FF0000')
        .setTimestamp();
      await interaction.channel.send({ embeds: [stopEmbed] });
      player.destroy();
      await interaction.reply({ content: '‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† tho√°t', ephemeral: true });
    } else {
      await interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });
    }
  }

  if (commandName === 'volume') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!', ephemeral: true });

    const volume = options.getInteger('level');
    if (volume < 0 || volume > 100) {
      return interaction.reply({ content: '√Çm l∆∞·ª£ng ph·∫£i t·ª´ 0 ƒë·∫øn 100!', ephemeral: true });
    }

    player.setVolume(volume);
    await interaction.reply(`üîä √Çm l∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh ${volume}%`);
  }

  if (commandName === '247') {
    const player = manager.players.get(interaction.guild.id);
    if (!player) return interaction.reply({ content: 'Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!', ephemeral: true });

    player.twentyFourSeven = !player.twentyFourSeven;
    const embed = new EmbedBuilder()
      .setDescription(`üéµ Ch·∫ø ƒë·ªô 24/7 hi·ªán ƒë√£ ${player.twentyFourSeven ? 'b·∫≠t' : 't·∫Øt'}`)
      .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'help') {
    const embed = new EmbedBuilder()
      .setTitle(`üéµ L·ªánh c·ªßa ${client.user.username}`)
      .setDescription('Ng∆∞·ªùi b·∫°n ƒë·ªìng h√†nh √¢m nh·∫°c v·ªõi ch·∫•t l∆∞·ª£ng ph√°t cao!')
      .addFields(
        { name: 'üéµ ƒêi·ªÅu khi·ªÉn √¢m nh·∫°c', value: 
          '`/play` - Ph√°t b√†i h√°t t·ª´ t√™n/URL\n' +
          '`/pause` - ‚è∏Ô∏è T·∫°m d·ª´ng ph√°t\n' +
          '`/resume` - ‚ñ∂Ô∏è Ti·∫øp t·ª•c ph√°t\n' +
          '`/stop` - ‚èπÔ∏è D·ª´ng v√† tho√°t\n' +
          '`/skip` - ‚è≠Ô∏è B·ªè qua b√†i hi·ªán t·∫°i\n' +
          '`/volume` - üîä ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (0-100)'
        },
        { name: 'üìë Qu·∫£n l√Ω danh s√°ch', value: 
          '`/queue` - üìú Xem danh s√°ch ph√°t\n' +
          '`/nowplaying` - üéµ Xem b√†i ƒëang ph√°t\n' +
          '`/shuffle` - üîÄ X√°o tr·ªôn danh s√°ch\n' +
          '`/loop` - üîÅ ƒê·∫∑t ch·∫ø ƒë·ªô l·∫∑p\n' +
          '`/remove` - ‚ùå X√≥a b√†i h√°t\n' +
          '`/move` - ‚ÜïÔ∏è Di chuy·ªÉn v·ªã tr√≠ b√†i h√°t'
        },
        { name: '‚öôÔ∏è Ti·ªán √≠ch', value: 
          '`/247` - üîÑ B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô 24/7\n' +
          '`/ping` - üì° Ki·ªÉm tra ƒë·ªô tr·ªÖ\n' +
          '`/stats` - üìä Xem th·ªëng k√™\n' +
          '`/invite` - üì® M·ªùi bot v√†o m√°y ch·ªß\n' +
          '`/support` - üí¨ Tham gia m√°y ch·ªß h·ªó tr·ª£'
        }
      )
      .setColor('#FF0000')
      .setThumbnail(client.user.displayAvatarURL())
      .setFooter({ 
        text: `T·∫°o b·ªüi NhatDuck ‚Ä¢ Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();
    return await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'invite') {
    const embed = new EmbedBuilder()
      .setTitle('üì® M·ªùi t√¥i')
      .setDescription(`[Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ m·ªùi t√¥i v√†o m√°y ch·ªß c·ªßa b·∫°n](https://discord.com/api/oauth2/authorize?client_id=${client.user.id}&permissions=8&scope=bot%20applications.commands)`)
      .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'ping') {
    const ping = Math.round(client.ws.ping);
    const embed = new EmbedBuilder()
      .setTitle('üèì Pong!')
      .setDescription(`ƒê·ªô tr·ªÖ WebSocket: ${ping}ms`)
      .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'stats') {
    const uptime = Math.round(client.uptime / 1000);
    const seconds = uptime % 60;
    const minutes = Math.floor((uptime % 3600) / 60);
    const hours = Math.floor((uptime % 86400) / 3600);
    const days = Math.floor(uptime / 86400);

    const embed = new EmbedBuilder()
      .setTitle('üìä Th·ªëng k√™ bot')
      .addFields(
        { name: '‚åö Th·ªùi gian ho·∫°t ƒë·ªông', value: `${days}d ${hours}h ${minutes}m ${seconds}s`, inline: true },
        { name: 'üéµ Ng∆∞·ªùi ch∆°i ƒëang ho·∫°t ƒë·ªông', value: `${manager.players.size}`, inline: true },
        { name: 'üåê M√°y ch·ªß', value: `${client.guilds.cache.size}`, inline: true },
        { name: 'üë• Ng∆∞·ªùi d√πng', value: `${client.users.cache.size}`, inline: true },
        { name: 'üì° Ping', value: `${Math.round(client.ws.ping)}ms`, inline: true }
      )
       .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === 'support') {
    const embed = new EmbedBuilder()
      .setTitle('üí¨ M√°y ch·ªß h·ªó tr·ª£')
      .setDescription(`[Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ tham gia m√°y ch·ªß h·ªó tr·ª£ c·ªßa ch√∫ng t√¥i](${process.env.SUPPORT_SERVER})`)
      .setColor('#FF0000')
      .setFooter({ 
        text: `Y√™u c·∫ßu b·ªüi ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL()
      })
      .setTimestamp();
    await interaction.reply({ embeds: [embed] });
  }
});

manager.on('nodeConnect', (node) => {
  console.log(`Node ${node.options.identifier} ƒë√£ k·∫øt n·ªëi`);
});

manager.on('nodeError', (node, error) => {
  console.error(`L·ªói node ${node.options.identifier}:`, error.message);
});

manager.on('trackStart', (player, track) => {
  const channel = client.channels.cache.get(player.textChannel);
  if (channel) {
    const embed = createMusicEmbed(track);
    const buttons = createControlButtons();
    channel.send({ embeds: [embed], components: buttons }).then(msg => {
      player.set('currentMessage', msg);
    });
  }
});

manager.on('queueEnd', (player) => {
  if (player.get('manualStop')) return;

  const channel = client.channels.cache.get(player.textChannel);
  if (channel) {
    const embed = new EmbedBuilder()
      .setDescription('Danh s√°ch ph√°t ƒë√£ k·∫øt th√∫c!')
      .setColor('#FF0000')
      .setTimestamp();
    channel.send({ embeds: [embed] });

    const message = player.get('currentMessage');
    if (message && message.editable) {
      const disabledButtons = message.components[0].components.map(button => {
        return ButtonBuilder.from(button).setDisabled(true);
      });
      message.edit({ components: [new ActionRowBuilder().addComponents(disabledButtons)] });
    }
  }
});

client.login(process.env.DISCORD_BOT_TOKEN);
